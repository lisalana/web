# Webserv - Serveur HTTP en C++98

## üìã Table des mati√®res
1. [Vue d'ensemble](#vue-densemble)
2. [Bases d'un serveur HTTP](#bases-dun-serveur-http)
3. [I/O Multiplexing avec Epoll](#io-multiplexing-avec-epoll)
4. [Architecture du serveur](#architecture-du-serveur)
5. [Gestion des erreurs](#gestion-des-erreurs)
6. [Configuration](#configuration)
7. [Fonctionnalit√©s](#fonctionnalit√©s)
---

## Vue d'ensemble

Webserv est un serveur HTTP/1.1 √©crit en C++98, capable de g√©rer plusieurs connexions simultan√©es de mani√®re non-bloquante gr√¢ce √† l'I/O Multiplexing avec `epoll`.

### Compilation
```bash
make
./webserv webserv.conf
```

---

##  Bases d'un serveur HTTP

### Qu'est-ce qu'un serveur HTTP ?

Un serveur HTTP est un programme qui :
1. **√âcoute** sur un port (ex: 8080)
2. **Accepte** des connexions de clients (navigateurs, curl, etc.)
3. **Re√ßoit** des requ√™tes HTTP (GET, POST, DELETE, etc.)
4. **Traite** ces requ√™tes (cherche un fichier, ex√©cute un CGI, etc.)
5. **Envoie** une r√©ponse HTTP avec un code de statut et du contenu

### Le cycle Requ√™te/R√©ponse
```
Client                          Serveur
  |                                |
  |--- GET /index.html HTTP/1.1 -->|  (1) Requ√™te
  |                                |
  |                                |  (2) Traitement
  |                                |      - Parse la requ√™te
  |                                |      - Trouve le fichier
  |                                |      - Lit le contenu
  |                                |
  |<-- HTTP/1.1 200 OK ------------|  (3) R√©ponse
  |    Content-Type: text/html     |
  |    Content-Length: 1234        |
  |                                |
  |    <html>...</html>            |
  |                                |
```

### M√©thodes HTTP principales

- **GET** : R√©cup√®re une ressource (fichier, page web)
- **POST** : Envoie des donn√©es au serveur (upload, formulaire)
- **DELETE** : Supprime une ressource

### Codes de statut HTTP

- **200 OK** : Succ√®s
- **201 Created** : Ressource cr√©√©e
- **301 Moved Permanently** : Redirection permanente
- **400 Bad Request** : Requ√™te malform√©e
- **403 Forbidden** : Acc√®s interdit
- **404 Not Found** : Ressource introuvable
- **405 Method Not Allowed** : M√©thode non autoris√©e
- **500 Internal Server Error** : Erreur serveur

---

## ‚ö° I/O Multiplexing avec Epoll

### Pourquoi l'I/O Multiplexing ?

Sans multiplexing, un serveur devrait cr√©er un thread par client ‚Üí impossible avec des milliers de connexions.

Avec `epoll`, **un seul thread** peut g√©rer des milliers de connexions simultan√©es en surveillant tous les sockets en m√™me temps.

### Fonction utilis√©e : `epoll` (Linux)

Notre serveur utilise `epoll` avec les fonctions :
- `epoll_create1()` : Cr√©e une instance epoll
- `epoll_ctl()` : Enregistre/modifie/supprime des file descriptors
- `epoll_wait()` : Attend qu'un √©v√©nement soit pr√™t

### Comment fonctionne epoll ?
```cpp
// 1. Cr√©er l'instance epoll
int epoll_fd = epoll_create1(0);

// 2. Enregistrer un socket pour surveiller les √©v√©nements
struct epoll_event event;
event.events = EPOLLIN | EPOLLOUT;  // Surveiller lecture ET √©criture
event.data.fd = client_fd;
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &event);

// 3. Attendre des √©v√©nements (bloquant jusqu'√† ce qu'un fd soit pr√™t)
struct epoll_event events[MAX_EVENTS];
int n = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);

// 4. Traiter les √©v√©nements pr√™ts
for (int i = 0; i < n; i++) {
    if (events[i].events & EPOLLIN) {
        // Socket pr√™t pour lecture
        handleRead(events[i].data.fd);
    }
    if (events[i].events & EPOLLOUT) {
        // Socket pr√™t pour √©criture
        handleWrite(events[i].data.fd);
    }
}
```

### Architecture : Un seul epoll pour tout

Notre serveur utilise **UN SEUL** `epoll_wait()` qui surveille :
- Les **listen sockets** (pour accepter de nouvelles connexions)
- Les **client sockets** en lecture (EPOLLIN)
- Les **client sockets** en √©criture (EPOLLOUT)
- Les **erreurs** (EPOLLERR, EPOLLHUP)

**Avantage** : Tous les √©v√©nements sont g√©r√©s en m√™me temps, dans la m√™me boucle.

---

##  Architecture du serveur

### Flux principal
```
main()
  ‚îî‚îÄ> Server::init()
       ‚îî‚îÄ> Cr√©er les listen sockets
       ‚îî‚îÄ> Enregistrer dans epoll avec callback handleNewConnection
  ‚îî‚îÄ> Server::start()
  ‚îî‚îÄ> Server::run()
       ‚îî‚îÄ> BOUCLE INFINIE:
            ‚îî‚îÄ> epoll_wait() [BLOQUE ICI]
            ‚îî‚îÄ> Pour chaque √©v√©nement pr√™t:
                 ‚îî‚îÄ> Appeler le callback appropri√©
                      ‚îú‚îÄ> handleNewConnection (nouveau client)
                      ‚îú‚îÄ> handleClientRead (donn√©es √† lire)
                      ‚îú‚îÄ> handleClientWrite (pr√™t √† √©crire)
                      ‚îî‚îÄ> handleClientError (erreur)
```

### Callbacks pour chaque type d'√©v√©nement

Nous utilisons des **callbacks** enregistr√©s dans epoll :

| Type d'√©v√©nement | Callback | R√¥le |
|-----------------|----------|------|
| Listen socket + EPOLLIN | `handleNewConnection` | Accepter un nouveau client |
| Client socket + EPOLLIN | `handleClientRead` | Lire les donn√©es du client |
| Client socket + EPOLLOUT | `handleClientWrite` | Envoyer la r√©ponse au client |
| Client socket + EPOLLERR | `handleClientError` | G√©rer les erreurs |

---


### Suppression du client en cas d'erreur

D√®s qu'une erreur survient sur un socket, le client est supprim√© :
```cpp
void Server::removeClient(int client_fd) {
    std::map<int, Client>::iterator it = _clients.find(client_fd);
    if (it != _clients.end()) {
        _epoll_manager.unbindFd(client_fd, -1);  // Retirer de epoll
        it->second.closeFd();                     // Fermer le socket
        _clients.erase(it);                       // Supprimer de la map
        Logger::info("Client disconnected", client_fd);
    }
}
```

### Pas d'I/O en dehors d'epoll

**R√àGLE ABSOLUE** : Tous les `recv()` et `send()` sont d√©clench√©s **UNIQUEMENT** par un √©v√©nement epoll.

 **INTERDIT** : Lire ou √©crire sur un socket sans √©v√©nement epoll
 **CORRECT** : Lire/√©crire uniquement quand epoll nous dit que c'est pr√™t

---

## ‚öôÔ∏è Configuration

Le serveur supporte un fichier de configuration au format NGINX-like :
```nginx
server {
    listen 8080;
    server_name localhost;
    
    # Page d'erreur personnalis√©e
    error_page 404 /errors/404.html;
    
    # Limite de taille du body (en bytes)
    client_max_body_size 10485760;  # 10MB
    
    location / {
        root ./static;
        index index.html;
        autoindex on;
        allowed_methods GET POST DELETE;
    }
    
    location /upload {
        root ./uploads;
        allowed_methods POST DELETE;
        client_max_body_size 52428800;  # 50MB pour uploads
    }
    
    location /redirect {
        return 301 /new-location;
    }
    
    location /cgi-bin {
        root ./cgi-bin;
        cgi_enabled on;
        cgi_extension .py;
    }
}

# Deuxi√®me serveur sur un autre port
server {
    listen 8081;
    server_name example.com;
    root ./site2;
}
```

### Tests de configuration
```bash
# 1. Plusieurs serveurs avec ports diff√©rents
curl http://localhost:8080/
curl http://localhost:8081/

# 2. Plusieurs serveurs avec hostnames diff√©rents
curl --resolve example.com:8080:127.0.0.1 http://example.com:8080/

# 3. Page d'erreur personnalis√©e
curl http://localhost:8080/page-inexistante  # Affiche errors/404.html

# 4. Limite de taille du body
curl -X POST -H "Content-Type: text/plain" \
     --data "SHORT" http://localhost:8080/  # ‚úÖ OK
curl -X POST -H "Content-Type: text/plain" \
     --data "$(head -c 20M /dev/urandom)" http://localhost:8080/  # ‚ùå 413

# 5. M√©thodes autoris√©es
curl -X DELETE http://localhost:8080/file.txt  # Si autoris√© dans config
curl -X DELETE http://localhost:8080/          # ‚ùå 405 si non autoris√©
```

---

## Fonctionnalit√©s

### M√©thodes HTTP

#### GET - R√©cup√©rer une ressource
```bash
curl http://localhost:8080/index.html
curl http://localhost:8080/test.txt
```

#### POST - Upload de fichier
```bash
curl -X POST -F "file=@document.pdf" http://localhost:8080/upload
```

#### DELETE - Supprimer un fichier
```bash
curl -X DELETE http://localhost:8080/uploads/document.pdf
```

#### Requ√™tes inconnues (ne crashe pas)
```bash
curl -X UNKNOWN http://localhost:8080/  # Retourne 501 Not Implemented
```

### Fonctionnalit√©s avanc√©es

#### 1. Servir des fichiers statiques
```bash
curl http://localhost:8080/styles.css
curl http://localhost:8080/script.js
curl http://localhost:8080/image.png
```

#### 2. Directory listing (autoindex)
```bash
curl http://localhost:8080/uploads/
# Affiche la liste des fichiers si autoindex est activ√©
```

#### 3. Redirections
```bash
curl -L http://localhost:8080/old-page  # Suit la redirection 301
```

#### 4. Upload et r√©cup√©ration
```bash
# Upload
curl -X POST -F "file=@test.txt" http://localhost:8080/upload

# R√©cup√©ration
curl http://localhost:8080/uploads/test.txt
```

#### 5. CGI (Python)
```bash
curl "http://localhost:8080/cgi-bin/script.py?name=John"
# Ex√©cute le script Python et retourne le r√©sultat
```

---

## üß™ Tests de stress avec Siege

### Installation
```bash
brew install siege
```

### Test basique
```bash
siege -b http://localhost:8080/index.html
```

### Test de stress
```bash
# 10 clients concurrents pendant 30 secondes
siege -b -c 10 -t 30S http://localhost:8080/

# R√©sultats attendus :
# - Availability: > 99.5%
# - Failed transactions: 0
# - Pas de crash
```

### Test avec Valgrind
```bash
# Terminal 1 : Serveur avec Valgrind
valgrind --leak-check=full --track-origins=yes ./webserv config.conf

# Terminal 2 : Stress test
siege -b -c 10 -t 30S http://localhost:8080/

# Terminal 1 : Ctrl+C pour arr√™ter
# V√©rifier : ERROR SUMMARY: 0 errors
#            All heap blocks were freed -- no leaks are possible
```

---

## üìä R√©sultats attendus

### Availability > 99.5%
```json
{
    "transactions": 3315,
    "availability": 100.00,        ‚Üê Doit √™tre > 99.5%
    "elapsed_time": 9.86,
    "response_time": 0.01,
    "successful_transactions": 3315,
    "failed_transactions": 0,      ‚Üê Doit √™tre 0
    "concurrency": 4.99
}
```

### Pas de memory leaks
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 439,102 allocs, 439,102 frees
==12345== 
==12345== All heap blocks were freed -- no leaks are possible
==12345== ERROR SUMMARY: 0 errors from 0 contexts
```

---

## üîß Arr√™t propre du serveur

Le serveur peut √™tre arr√™t√© de deux mani√®res :

### 1. Ctrl+C (Signal SIGINT/SIGTERM)
```bash
./webserv config.conf
# Ctrl+C
# [INFO] Received shutdown signal
# [INFO] Server stopped
```

### 2. Route /stop (via navigateur)
```
http://localhost:8080/
# Cliquer sur le bouton "Stop Server"
# Le serveur s'arr√™te proprement
```

Les deux m√©thodes garantissent :
- ‚úÖ Fermeture propre de tous les sockets
- ‚úÖ Lib√©ration de toute la m√©moire
- ‚úÖ Pas de use-after-free
- ‚úÖ Pas de hanging connections

---

### ‚úÖ Ce qui est correct dans notre serveur :

1. **Un seul epoll_wait()** dans la boucle principale
2. **Surveille lecture ET √©criture simultan√©ment** (EPOLLIN | EPOLLOUT)
3. **Un seul recv() / send() par √©v√©nement**
4. **V√©rification compl√®te des valeurs de retour** (both 0 and -1)
5. **Pas de v√©rification d'errno apr√®s succ√®s**
6. **Tous les I/O passent par epoll** (pas de read/write direct)
7. **Suppression du client en cas d'erreur**
8. **Pas de memory leaks** (test√© avec Valgrind)
9. **Availability > 99.5%** avec Siege
10. **Arr√™t propre** via signal ou /stop

---

## Auteurs

Projet Webserv - 42 school 
-Lsadi
-Rguigneb
-Reer.aa

---

## üìö Ressources

- [RFC 2616 - HTTP/1.1](https://www.rfc-editor.org/rfc/rfc2616)
- [epoll man page](https://man7.org/linux/man-pages/man7/epoll.7.html)
- [Beej's Guide to Network Programming](https://beej.us/guide/bgnet/)